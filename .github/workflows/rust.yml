name: Build Windows EXE (signed) + Release ZIP - test

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-windows-exe:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri -> target

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.7

      - name: Enable sccache
        shell: pwsh
        run: |
          "RUSTC_WRAPPER=sccache" | Out-File -Append $env:GITHUB_ENV
          "SCCACHE_CACHE_SIZE=2G"  | Out-File -Append $env:GITHUB_ENV

      - name: Install Tauri CLI
        run: cargo install tauri-cli --locked --version ^1.6

      - name: Stage web assets to ./dist
        shell: pwsh
        run: |
          if (Test-Path dist) { Remove-Item -Recurse -Force dist }
          New-Item -ItemType Directory -Force dist | Out-Null
          Copy-Item src-tauri\assets\* dist -Recurse -Force
          if (-not (Test-Path dist\index.html)) { Write-Error "index.html missing in staged dist" }

      - name: Generate icons (idempotent)
        run: cargo tauri icon src-tauri/icon.png

      - name: Prepare code signing (optional)
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          if ($env:WINDOWS_CERTIFICATE -and $env:WINDOWS_CERTIFICATE_PASSWORD) {
            New-Item -ItemType Directory -Force certificate | Out-Null
            Set-Content certificate\cert.b64 $env:WINDOWS_CERTIFICATE
            certutil -decode certificate\cert.b64 certificate\codesign.pfx | Out-Null
            "TAURI_WIN_CERT_PATH=$(Resolve-Path certificate\codesign.pfx)" | Out-File -FilePath $env:GITHUB_ENV -Append
            "TAURI_WIN_CERT_PASS=$($env:WINDOWS_CERTIFICATE_PASSWORD)" | Out-File -FilePath $env:GITHUB_ENV -Append
          }

      - name: Build portable EXE
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_WIN_CERT_PATH: ${{ env.TAURI_WIN_CERT_PATH }}
          TAURI_WIN_CERT_PASS: ${{ env:TAURI_WIN_CERT_PASS }}
          TAURI_BUNDLE_TARGETS: app
        with:
          bundles: app
          args: --config src-tauri/tauri.ci.json

      # ⬇️ ZIP "safe" : EXE dans bin/ + README (au lieu d'un EXE à la racine)
      - name: Prepare release asset (safe zip + sha256)
        id: prep
        shell: pwsh
        run: |
          $ErrorActionPreference='Stop'

          # Trouver l'exe
          $exe = Get-ChildItem src-tauri/target/release -Filter TauriKargo*.exe -Recurse | Select-Object -First 1
          if (-not $exe) { Write-Error "No EXE found after build." }

          # Version depuis Cargo.toml
          $toml = Get-Content src-tauri\Cargo.toml -Raw
          if ($toml -match '(?m)^\s*version\s*=\s*"([^"]+)"') { $v = $Matches[1] } else { $v = "0.0.0" }

          # Noms de sortie
          $zipName = "TauriKargo-$v-windows-x64.zip"
          $exePublish = "TauriKargo-$v-windows-x64.exe"

          # Dossier de staging pour le ZIP
          $root = Join-Path $pwd ("TauriKargo-" + $v)
          if (Test-Path $root) { Remove-Item $root -Recurse -Force }
          New-Item -ItemType Directory -Force $root | Out-Null

          $bin = Join-Path $root "bin"
          New-Item -ItemType Directory -Force $bin | Out-Null

          # Copier l'exe sous un nom stable dans bin/
          Copy-Item -LiteralPath $exe.FullName -Destination (Join-Path $bin $exePublish) -Force

          # Petit README (utile si SmartScreen/MOTW)
          @(
            "TauriKargo $v"
            ""
            "Contenu:"
            "  - bin\$exePublish"
            ""
            "Note: si Windows bloque le fichier après extraction,"
            "clic droit sur le ZIP > Propriétés > 'Débloquer', puis re-dézipper."
          ) | Set-Content (Join-Path $root "README.txt")

          # Créer le ZIP (écrase si existant)
          if (Test-Path $zipName) { Remove-Item $zipName -Force }
          Compress-Archive -Path (Join-Path $root '*') -DestinationPath $zipName

          # Hash ZIP + chemin EXE d'origine
          $sha256 = (Get-FileHash $zipName -Algorithm SHA256).Hash

          # Sorties
          "exe_src=$($exe.FullName)"      | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "exe_pub=$exePublish"           | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "zip=$zipName"                  | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "sha256=$sha256"                | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$v"                    | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      # Attacher ZIP + EXE à la Release (liens directs)
      - name: Create or update Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: Latest signed build
          make_latest: true
          prerelease: true
          draft: false
          files: |
            ${{ steps.prep.outputs.zip }}
            ${{ steps.prep.outputs.exe_src }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Job summary
        shell: pwsh
        run: |
          $zip="${{ steps.prep.outputs.zip }}"
          $exeSrc="${{ steps.prep.outputs.exe_src }}"
          $sha="${{ steps.prep.outputs.sha256 }}"
          $v="${{ steps.prep.outputs.version }}"
          @(
            "# Build Windows (cache + signature si secrets)"
            "Version : $v"
            "EXE (brut) : $exeSrc"
            "ZIP (safe) : $zip"
            "SHA256 ZIP : $sha"
            ""
            "Téléchargez depuis Releases -> Latest signed build (liens directs)."
          ) | Set-Content -Path $env:GITHUB_STEP_SUMMARY -Encoding utf8

      # (Optionnel) Artifacts Actions — resteront toujours emballés en .zip côté Actions
      - name: Upload artifact (EXE)
        uses: actions/upload-artifact@v4
        with:
          name: tauri-windows-exe
          path: ${{ steps.prep.outputs.exe_src }}
          if-no-files-found: error
          compression-level: 0
