name: Sign Windows EXE (by run_id)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: "Run ID du build ayant publié l'artifact"
        required: true
      artifact_name:
        description: "Nom exact de l'artifact à télécharger (contient l'EXE)"
        required: true
        default: "tauri-windows-exe"
      tag_name:
        description: "Tag de Release (ex: v1.2.3)"
        required: false
        default: latest
      release_name:
        description: "Nom/Titre de la Release"
        required: false
        default: "Latest signed build"

permissions:
  actions: read
  contents: write

jobs:
  sign:
    runs-on: windows-latest
    steps:
      - name: Download EXE artifact from run
        uses: dawidd6/action-download-artifact@v3
        with:
          run_id: ${{ inputs.run_id }}
          name: ${{ inputs.artifact_name }}
          if_no_artifact_found: fail

      - name: Require signing secrets
        shell: pwsh
        run: |
          if (-not "${{ secrets.WINDOWS_CERTIFICATE }}" -or -not "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}") {
            Write-Error "Missing secrets: WINDOWS_CERTIFICATE / WINDOWS_CERTIFICATE_PASSWORD"
          }

      - name: Decode PFX
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
        run: |
          New-Item -ItemType Directory -Force certificate | Out-Null
          Set-Content certificate\cert.b64 $env:WINDOWS_CERTIFICATE
          certutil -decode certificate\cert.b64 certificate\codesign.pfx | Out-Null

      - name: Resolve signtool.exe
        shell: pwsh
        run: |
          $st = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
            Sort-Object FullName -Descending | Select-Object -First 1 -ExpandProperty FullName
          if (-not $st) {
            choco install windows-sdk-10-version-10.0.22621.0 -y
            $st = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending | Select-Object -First 1 -ExpandProperty FullName
          }
          if (-not $st) { Write-Error "signtool.exe not found." }
          "SIGNTOOL=$st" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Locate EXE
        id: find
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path . -Filter *.exe -Recurse | Sort-Object Length -Descending | Select-Object -First 1
          if (-not $exe) { Write-Error "No .exe found in downloaded artifact." }
          "exe=$($exe.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "EXE => $($exe.FullName)"

      - name: Sign EXE (RFC3161 then /t)
        shell: pwsh
        env:
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          $exe = "${{ steps.find.outputs.exe }}"
          $ok = $false
          $rfc = @("http://timestamp.digicert.com","http://timestamp.sectigo.com/rfc3161","http://rfc3161timestamp.globalsign.com/advanced")
          foreach ($u in $rfc) {
            & "$env:SIGNTOOL" sign /fd sha256 /f certificate\codesign.pfx /p "$env:WINDOWS_CERTIFICATE_PASSWORD" /tr $u /td sha256 /d "TauriKargo" "$exe"
            if ($LASTEXITCODE -eq 0) { $ok = $true; break } else { Write-Warning "RFC3161 fail: $u" }
          }
          if (-not $ok) {
            $legacy=@("http://timestamp.digicert.com","http://timestamp.sectigo.com","http://timestamp.globalsign.com/scripts/timestamp.dll")
            foreach ($u in $legacy) {
              & "$env:SIGNTOOL" sign /fd sha256 /f certificate\codesign.pfx /p "$env:WINDOWS_CERTIFICATE_PASSWORD" /t $u /d "TauriKargo" "$exe"
              if ($LASTEXITCODE -eq 0) { $ok = $true; break } else { Write-Warning "legacy /t fail: $u" }
            }
          }
          if (-not $ok) { Write-Error "All timestamp servers failed." }

      - name: Build release/ and ZIP (safe layout)
        id: pack
        shell: pwsh
        run: |
          $ErrorActionPreference='Stop'
          Add-Type -AssemblyName System.IO.Compression.FileSystem

          $ws = "${{ github.workspace }}"
          $relDir = Join-Path $ws "release"
          if (Test-Path $relDir) { Remove-Item $relDir -Recurse -Force }
          New-Item -ItemType Directory -Force $relDir | Out-Null

          $exeAbs = "${{ steps.find.outputs.exe }}"
          $exeName = Split-Path $exeAbs -Leaf
          $exeOut  = Join-Path $relDir $exeName
          Copy-Item -LiteralPath $exeAbs -Destination $exeOut -Force

          # ZIP final: même dossier release + nom fixe demandé
          $zipOut = Join-Path $relDir "TauriKargo-windows-x64.zip"

          # On met l'EXE dans un sous-dossier pour éviter les flags AV
          $tmpFolder = Join-Path $relDir "TauriKargo"
          New-Item -ItemType Directory -Force $tmpFolder | Out-Null
          $bin = Join-Path $tmpFolder "bin"
          New-Item -ItemType Directory -Force $bin | Out-Null
          Copy-Item -LiteralPath $exeOut -Destination (Join-Path $bin $exeName) -Force
          "See bin\$exeName" | Set-Content (Join-Path $tmpFolder "README.txt")

          if (Test-Path $zipOut) { Remove-Item $zipOut -Force }
          [IO.Compression.ZipFile]::CreateFromDirectory($tmpFolder, $zipOut, [IO.Compression.CompressionLevel]::Optimal, $true)

          # Sorties POSIX relatives pour la Release + Artifacts
          $exeRel = "release/$exeName"
          $zipRel = "release/TauriKargo-windows-x64.zip"
          "exe_rel=$exeRel" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "zip_rel=$zipRel" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          Write-Host "EXE => $exeRel"
          Write-Host "ZIP => $zipRel"

      # === Artifacts (lisibles dans l'onglet Actions) ===
      - name: Upload signed exe (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: signed-exe
          path: ${{ steps.pack.outputs.exe_rel }}
          if-no-files-found: error
          compression-level: 0

      - name: Upload signed zip (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: signed-zip
          path: ${{ steps.pack.outputs.zip_rel }}
          if-no-files-found: error
          compression-level: 0

      # === Release GitHub (liens stables) ===
      - name: Create / Update Pre-release (no files)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.tag_name }}
          name: ${{ inputs.release_name }}
          prerelease: true
          make_latest: true
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload assets via gh (clobber)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "${{ inputs.tag_name }}" "${{ steps.pack.outputs.zip_rel }}" --clobber
          gh release upload "${{ inputs.tag_name }}" "${{ steps.pack.outputs.exe_rel }}" --clobber

      - name: Summary
        shell: pwsh
        run: |
          @(
            "# Signing & Release summary"
            "EXE : ${{ steps.pack.outputs.exe_rel }}"
            "ZIP : ${{ steps.pack.outputs.zip_rel }}"
            "Tag : ${{ inputs.tag_name }}"
          ) | Set-Content -Path $env:GITHUB_STEP_SUMMARY -Encoding utf8
